"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkingStrategy = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
/**
 * Knowledge base can split your source data into chunks. A chunk refers to an
 * excerpt from a data source that is returned when the knowledge base that it
 * belongs to is queried. You have the following options for chunking your
 * data. If you opt for NONE, then you may want to pre-process your files by
 * splitting them up such that each file corresponds to a chunk.
 */
var ChunkingStrategyType;
(function (ChunkingStrategyType) {
    /**
     * Amazon Bedrock splits your source data into chunks of the approximate size
     * that you set in the `fixedSizeChunkingConfiguration`.
     */
    ChunkingStrategyType["FIXED_SIZE"] = "FIXED_SIZE";
    /**
     * Splits documents into layers of chunks where the first layer contains large
     * chunks, and the second layer contains smaller chunks derived from the first
     * layer. You set the maximum parent chunk token size and the maximum child
     * chunk token size. You also set the absolute number of overlap tokens between
     * consecutive parent chunks and consecutive child chunks.
     */
    ChunkingStrategyType["HIERARCHICAL"] = "HIERARCHICAL";
    /**
     * Splits documents into semantically similar text chunks or groups of
     * sentences by using a foundation model. Note that there are additional
     * costs to using semantic chunking due to its use of a foundation model.
     */
    ChunkingStrategyType["SEMANTIC"] = "SEMANTIC";
    /**
     * Amazon Bedrock treats each file as one chunk. If you choose this option,
     * you may want to pre-process your documents by splitting them into separate
     * files.
     */
    ChunkingStrategyType["NONE"] = "NONE";
})(ChunkingStrategyType || (ChunkingStrategyType = {}));
class ChunkingStrategy {
    // ------------------------------------------------------
    // Static Methods for Customization
    // ------------------------------------------------------
    /** Method for customizing a fixed sized chunking strategy. */
    static fixedSize(props) {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.FIXED_SIZE,
                fixedSizeChunkingConfiguration: props,
            },
        };
    }
    /**
     * Method for customizing a hierarchical chunking strategy.
     * For custom chunking, the maximum token chunk size depends on the model.
     * - Amazon Titan Text Embeddings: 8192
     * - Cohere Embed models: 512
    */
    static hierarchical(props) {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.HIERARCHICAL,
                hierarchicalChunkingConfiguration: {
                    overlapTokens: props.overlapTokens,
                    levelConfigurations: [
                        { maxTokens: props.maxParentTokenSize },
                        { maxTokens: props.maxChildTokenSize },
                    ],
                },
            },
        };
    }
    /**
     * Method for customizing a semantic chunking strategy.
     * For custom chunking, the maximum token chunk size depends on the model.
     * - Amazon Titan Text Embeddings: 8192
     * - Cohere Embed models: 512
    */
    static semantic(props) {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.SEMANTIC,
                semanticChunkingConfiguration: props,
            },
        };
    }
    /** Method for defining a no chunking strategy. */
    static noChunking() {
        return {
            configuration: {
                chunkingStrategy: ChunkingStrategyType.NONE,
            },
        };
    }
    constructor() { }
}
exports.ChunkingStrategy = ChunkingStrategy;
_a = JSII_RTTI_SYMBOL_1;
ChunkingStrategy[_a] = { fqn: "@cdklabs/generative-ai-cdk-constructs.bedrock.ChunkingStrategy", version: "0.1.285" };
// ------------------------------------------------------
// Static Constants for Easy Customization
// ------------------------------------------------------
/**
 * Fixed Sized Chunking with the default chunk size of 300 tokens and 20% overlap.
 */
ChunkingStrategy.DEFAULT = ChunkingStrategy.fixedSize({ maxTokens: 300, overlapPercentage: 20 });
/**
 * Fixed Sized Chunking with the default chunk size of 300 tokens and 20% overlap.
 * You can adjust these values based on your specific requirements using the
 * `ChunkingStrategy.fixedSize(params)` method.
 */
ChunkingStrategy.FIXED_SIZE = ChunkingStrategy.fixedSize({ maxTokens: 300, overlapPercentage: 20 });
/**
 * Hierarchical Chunking with the default for Cohere Models.
 * - Overlap tokens: 30
 * - Max parent token size: 500
 * - Max child token size: 100
 */
ChunkingStrategy.HIERARCHICAL_COHERE = ChunkingStrategy.hierarchical({ overlapTokens: 60, maxParentTokenSize: 500, maxChildTokenSize: 300 });
/**
 * Hierarchical Chunking with the default for Titan Models.
 * - Overlap tokens: 60
 * - Max parent token size: 1500
 * - Max child token size: 300
 */
ChunkingStrategy.HIERARCHICAL_TITAN = ChunkingStrategy.hierarchical({ overlapTokens: 60, maxParentTokenSize: 1500, maxChildTokenSize: 300 });
/**
 * Semantic Chunking with the default of bufferSize: 0,
 * breakpointPercentileThreshold: 95, and maxTokens: 300.
 * You can adjust these values based on your specific requirements using the
 * `ChunkingStrategy.semantic(params)` method.
 */
ChunkingStrategy.SEMANTIC = ChunkingStrategy.semantic({ bufferSize: 0, breakpointPercentileThreshold: 95, maxTokens: 300 });
/**
 * Amazon Bedrock treats each file as one chunk. Suitable for documents that
 * are already pre-processed or text split.
 */
ChunkingStrategy.NONE = ChunkingStrategy.noChunking();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2h1bmtpbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY2RrLWxpYi9iZWRyb2NrL2RhdGEtc291cmNlcy9jaHVua2luZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQWNBOzs7Ozs7R0FNRztBQUNILElBQUssb0JBMEJKO0FBMUJELFdBQUssb0JBQW9CO0lBQ3ZCOzs7T0FHRztJQUNILGlEQUF5QixDQUFBO0lBQ3pCOzs7Ozs7T0FNRztJQUNILHFEQUE2QixDQUFBO0lBQzdCOzs7O09BSUc7SUFDSCw2Q0FBcUIsQ0FBQTtJQUNyQjs7OztPQUlHO0lBQ0gscUNBQWEsQ0FBQTtBQUNmLENBQUMsRUExQkksb0JBQW9CLEtBQXBCLG9CQUFvQixRQTBCeEI7QUFtQkQsTUFBc0IsZ0JBQWdCO0lBb0RwQyx5REFBeUQ7SUFDekQsbUNBQW1DO0lBQ25DLHlEQUF5RDtJQUN6RCw4REFBOEQ7SUFDdkQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUEyRDtRQUNqRixPQUFPO1lBQ0wsYUFBYSxFQUFFO2dCQUNiLGdCQUFnQixFQUFFLG9CQUFvQixDQUFDLFVBQVU7Z0JBQ2pELDhCQUE4QixFQUFFLEtBQUs7YUFDdEM7U0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7OztNQUtFO0lBQ0ssTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFnQztRQUN6RCxPQUFPO1lBQ0wsYUFBYSxFQUFFO2dCQUNiLGdCQUFnQixFQUFFLG9CQUFvQixDQUFDLFlBQVk7Z0JBQ25ELGlDQUFpQyxFQUFFO29CQUNqQyxhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWE7b0JBQ2xDLG1CQUFtQixFQUFFO3dCQUNuQixFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsa0JBQWtCLEVBQUU7d0JBQ3ZDLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxpQkFBaUIsRUFBRTtxQkFDdkM7aUJBQ0Y7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7O01BS0U7SUFDSyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQTBEO1FBQy9FLE9BQU87WUFDTCxhQUFhLEVBQUU7Z0JBQ2IsZ0JBQWdCLEVBQUUsb0JBQW9CLENBQUMsUUFBUTtnQkFDL0MsNkJBQTZCLEVBQUUsS0FBSzthQUNyQztTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsa0RBQWtEO0lBQzFDLE1BQU0sQ0FBQyxVQUFVO1FBQ3ZCLE9BQU87WUFDTCxhQUFhLEVBQUU7Z0JBQ2IsZ0JBQWdCLEVBQUUsb0JBQW9CLENBQUMsSUFBSTthQUM1QztTQUNGLENBQUM7SUFDSixDQUFDO0lBT0QsZ0JBQXdCLENBQUM7O0FBbkgzQiw0Q0FvSEM7OztBQW5IQyx5REFBeUQ7QUFDekQsMENBQTBDO0FBQzFDLHlEQUF5RDtBQUN6RDs7R0FFRztBQUNvQix3QkFBTyxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FDekQsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsRUFBRSxDQUMxQyxDQUFDO0FBQ0Y7Ozs7R0FJRztBQUNvQiwyQkFBVSxHQUFHLGdCQUFnQixDQUFDLFNBQVMsQ0FDNUQsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsRUFBRSxDQUMxQyxDQUFDO0FBQ0Y7Ozs7O0dBS0c7QUFDb0Isb0NBQW1CLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUN4RSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxDQUN2RSxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDb0IsbUNBQWtCLEdBQUcsZ0JBQWdCLENBQUMsWUFBWSxDQUN2RSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsa0JBQWtCLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsRUFBRSxDQUN4RSxDQUFDO0FBQ0Y7Ozs7O0dBS0c7QUFDb0IseUJBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxRQUFRLENBQ3pELEVBQUUsVUFBVSxFQUFFLENBQUMsRUFBRSw2QkFBNkIsRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUNyRSxDQUFDO0FBQ0Y7OztHQUdHO0FBQ29CLHFCQUFJLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKS4gWW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogIHdpdGggdGhlIExpY2Vuc2UuIEEgY29weSBvZiB0aGUgTGljZW5zZSBpcyBsb2NhdGVkIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgb3IgaW4gdGhlICdsaWNlbnNlJyBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZCBvbiBhbiAnQVMgSVMnIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVNcbiAqICBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xuICogIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IHsgQ2ZuRGF0YVNvdXJjZSB9IGZyb20gJ2F3cy1jZGstbGliL2F3cy1iZWRyb2NrJztcblxuLyoqXG4gKiBLbm93bGVkZ2UgYmFzZSBjYW4gc3BsaXQgeW91ciBzb3VyY2UgZGF0YSBpbnRvIGNodW5rcy4gQSBjaHVuayByZWZlcnMgdG8gYW5cbiAqIGV4Y2VycHQgZnJvbSBhIGRhdGEgc291cmNlIHRoYXQgaXMgcmV0dXJuZWQgd2hlbiB0aGUga25vd2xlZGdlIGJhc2UgdGhhdCBpdFxuICogYmVsb25ncyB0byBpcyBxdWVyaWVkLiBZb3UgaGF2ZSB0aGUgZm9sbG93aW5nIG9wdGlvbnMgZm9yIGNodW5raW5nIHlvdXJcbiAqIGRhdGEuIElmIHlvdSBvcHQgZm9yIE5PTkUsIHRoZW4geW91IG1heSB3YW50IHRvIHByZS1wcm9jZXNzIHlvdXIgZmlsZXMgYnlcbiAqIHNwbGl0dGluZyB0aGVtIHVwIHN1Y2ggdGhhdCBlYWNoIGZpbGUgY29ycmVzcG9uZHMgdG8gYSBjaHVuay5cbiAqL1xuZW51bSBDaHVua2luZ1N0cmF0ZWd5VHlwZSB7XG4gIC8qKlxuICAgKiBBbWF6b24gQmVkcm9jayBzcGxpdHMgeW91ciBzb3VyY2UgZGF0YSBpbnRvIGNodW5rcyBvZiB0aGUgYXBwcm94aW1hdGUgc2l6ZVxuICAgKiB0aGF0IHlvdSBzZXQgaW4gdGhlIGBmaXhlZFNpemVDaHVua2luZ0NvbmZpZ3VyYXRpb25gLlxuICAgKi9cbiAgRklYRURfU0laRSA9ICdGSVhFRF9TSVpFJyxcbiAgLyoqXG4gICAqIFNwbGl0cyBkb2N1bWVudHMgaW50byBsYXllcnMgb2YgY2h1bmtzIHdoZXJlIHRoZSBmaXJzdCBsYXllciBjb250YWlucyBsYXJnZVxuICAgKiBjaHVua3MsIGFuZCB0aGUgc2Vjb25kIGxheWVyIGNvbnRhaW5zIHNtYWxsZXIgY2h1bmtzIGRlcml2ZWQgZnJvbSB0aGUgZmlyc3RcbiAgICogbGF5ZXIuIFlvdSBzZXQgdGhlIG1heGltdW0gcGFyZW50IGNodW5rIHRva2VuIHNpemUgYW5kIHRoZSBtYXhpbXVtIGNoaWxkXG4gICAqIGNodW5rIHRva2VuIHNpemUuIFlvdSBhbHNvIHNldCB0aGUgYWJzb2x1dGUgbnVtYmVyIG9mIG92ZXJsYXAgdG9rZW5zIGJldHdlZW5cbiAgICogY29uc2VjdXRpdmUgcGFyZW50IGNodW5rcyBhbmQgY29uc2VjdXRpdmUgY2hpbGQgY2h1bmtzLlxuICAgKi9cbiAgSElFUkFSQ0hJQ0FMID0gJ0hJRVJBUkNISUNBTCcsXG4gIC8qKlxuICAgKiBTcGxpdHMgZG9jdW1lbnRzIGludG8gc2VtYW50aWNhbGx5IHNpbWlsYXIgdGV4dCBjaHVua3Mgb3IgZ3JvdXBzIG9mXG4gICAqIHNlbnRlbmNlcyBieSB1c2luZyBhIGZvdW5kYXRpb24gbW9kZWwuIE5vdGUgdGhhdCB0aGVyZSBhcmUgYWRkaXRpb25hbFxuICAgKiBjb3N0cyB0byB1c2luZyBzZW1hbnRpYyBjaHVua2luZyBkdWUgdG8gaXRzIHVzZSBvZiBhIGZvdW5kYXRpb24gbW9kZWwuXG4gICAqL1xuICBTRU1BTlRJQyA9ICdTRU1BTlRJQycsXG4gIC8qKlxuICAgKiBBbWF6b24gQmVkcm9jayB0cmVhdHMgZWFjaCBmaWxlIGFzIG9uZSBjaHVuay4gSWYgeW91IGNob29zZSB0aGlzIG9wdGlvbixcbiAgICogeW91IG1heSB3YW50IHRvIHByZS1wcm9jZXNzIHlvdXIgZG9jdW1lbnRzIGJ5IHNwbGl0dGluZyB0aGVtIGludG8gc2VwYXJhdGVcbiAgICogZmlsZXMuXG4gICAqL1xuICBOT05FID0gJ05PTkUnLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoaWNhbENodW5raW5nUHJvcHMge1xuICAvKipcbiAgICogVGhlIG92ZXJsYXAgdG9rZW5zIGJldHdlZW4gYWRqYWNlbnQgY2h1bmtzLlxuICAgKi9cbiAgcmVhZG9ubHkgb3ZlcmxhcFRva2VuczogbnVtYmVyO1xuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgdG9rZW5zIHRoYXQgYSBwYXJlbnQgY2h1bmsgY2FuIGNvbnRhaW4uXG4gICAqIEtlZXAgaW4gbWluZCB0aGUgbWF4aW11bSBjaHVuayBzaXplIGRlcGVuZHMgb24gdGhlIGVtYmVkZGluZyBtb2RlbCBjaG9zZW4uXG4gICAqL1xuICByZWFkb25seSBtYXhQYXJlbnRUb2tlblNpemU6IG51bWJlcjtcbiAgLyoqXG4gICAqIE1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0aGF0IGEgY2hpbGQgY2h1bmsgY2FuIGNvbnRhaW4uXG4gICAqIEtlZXAgaW4gbWluZCB0aGUgbWF4aW11bSBjaHVuayBzaXplIGRlcGVuZHMgb24gdGhlIGVtYmVkZGluZyBtb2RlbCBjaG9zZW4uXG4gICAqL1xuICByZWFkb25seSBtYXhDaGlsZFRva2VuU2l6ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2h1bmtpbmdTdHJhdGVneSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdGF0aWMgQ29uc3RhbnRzIGZvciBFYXN5IEN1c3RvbWl6YXRpb25cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBGaXhlZCBTaXplZCBDaHVua2luZyB3aXRoIHRoZSBkZWZhdWx0IGNodW5rIHNpemUgb2YgMzAwIHRva2VucyBhbmQgMjAlIG92ZXJsYXAuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERFRkFVTFQgPSBDaHVua2luZ1N0cmF0ZWd5LmZpeGVkU2l6ZShcbiAgICB7IG1heFRva2VuczogMzAwLCBvdmVybGFwUGVyY2VudGFnZTogMjAgfSxcbiAgKTtcbiAgLyoqXG4gICAqIEZpeGVkIFNpemVkIENodW5raW5nIHdpdGggdGhlIGRlZmF1bHQgY2h1bmsgc2l6ZSBvZiAzMDAgdG9rZW5zIGFuZCAyMCUgb3ZlcmxhcC5cbiAgICogWW91IGNhbiBhZGp1c3QgdGhlc2UgdmFsdWVzIGJhc2VkIG9uIHlvdXIgc3BlY2lmaWMgcmVxdWlyZW1lbnRzIHVzaW5nIHRoZVxuICAgKiBgQ2h1bmtpbmdTdHJhdGVneS5maXhlZFNpemUocGFyYW1zKWAgbWV0aG9kLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBGSVhFRF9TSVpFID0gQ2h1bmtpbmdTdHJhdGVneS5maXhlZFNpemUoXG4gICAgeyBtYXhUb2tlbnM6IDMwMCwgb3ZlcmxhcFBlcmNlbnRhZ2U6IDIwIH0sXG4gICk7XG4gIC8qKlxuICAgKiBIaWVyYXJjaGljYWwgQ2h1bmtpbmcgd2l0aCB0aGUgZGVmYXVsdCBmb3IgQ29oZXJlIE1vZGVscy5cbiAgICogLSBPdmVybGFwIHRva2VuczogMzBcbiAgICogLSBNYXggcGFyZW50IHRva2VuIHNpemU6IDUwMFxuICAgKiAtIE1heCBjaGlsZCB0b2tlbiBzaXplOiAxMDBcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgSElFUkFSQ0hJQ0FMX0NPSEVSRSA9IENodW5raW5nU3RyYXRlZ3kuaGllcmFyY2hpY2FsKFxuICAgIHsgb3ZlcmxhcFRva2VuczogNjAsIG1heFBhcmVudFRva2VuU2l6ZTogNTAwLCBtYXhDaGlsZFRva2VuU2l6ZTogMzAwIH0sXG4gICk7XG5cbiAgLyoqXG4gICAqIEhpZXJhcmNoaWNhbCBDaHVua2luZyB3aXRoIHRoZSBkZWZhdWx0IGZvciBUaXRhbiBNb2RlbHMuXG4gICAqIC0gT3ZlcmxhcCB0b2tlbnM6IDYwXG4gICAqIC0gTWF4IHBhcmVudCB0b2tlbiBzaXplOiAxNTAwXG4gICAqIC0gTWF4IGNoaWxkIHRva2VuIHNpemU6IDMwMFxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBISUVSQVJDSElDQUxfVElUQU4gPSBDaHVua2luZ1N0cmF0ZWd5LmhpZXJhcmNoaWNhbChcbiAgICB7IG92ZXJsYXBUb2tlbnM6IDYwLCBtYXhQYXJlbnRUb2tlblNpemU6IDE1MDAsIG1heENoaWxkVG9rZW5TaXplOiAzMDAgfSxcbiAgKTtcbiAgLyoqXG4gICAqIFNlbWFudGljIENodW5raW5nIHdpdGggdGhlIGRlZmF1bHQgb2YgYnVmZmVyU2l6ZTogMCxcbiAgICogYnJlYWtwb2ludFBlcmNlbnRpbGVUaHJlc2hvbGQ6IDk1LCBhbmQgbWF4VG9rZW5zOiAzMDAuXG4gICAqIFlvdSBjYW4gYWRqdXN0IHRoZXNlIHZhbHVlcyBiYXNlZCBvbiB5b3VyIHNwZWNpZmljIHJlcXVpcmVtZW50cyB1c2luZyB0aGVcbiAgICogYENodW5raW5nU3RyYXRlZ3kuc2VtYW50aWMocGFyYW1zKWAgbWV0aG9kLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBTRU1BTlRJQyA9IENodW5raW5nU3RyYXRlZ3kuc2VtYW50aWMoXG4gICAgeyBidWZmZXJTaXplOiAwLCBicmVha3BvaW50UGVyY2VudGlsZVRocmVzaG9sZDogOTUsIG1heFRva2VuczogMzAwIH0sXG4gICk7XG4gIC8qKlxuICAgKiBBbWF6b24gQmVkcm9jayB0cmVhdHMgZWFjaCBmaWxlIGFzIG9uZSBjaHVuay4gU3VpdGFibGUgZm9yIGRvY3VtZW50cyB0aGF0XG4gICAqIGFyZSBhbHJlYWR5IHByZS1wcm9jZXNzZWQgb3IgdGV4dCBzcGxpdC5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgTk9ORSA9IENodW5raW5nU3RyYXRlZ3kubm9DaHVua2luZygpO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBTdGF0aWMgTWV0aG9kcyBmb3IgQ3VzdG9taXphdGlvblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqIE1ldGhvZCBmb3IgY3VzdG9taXppbmcgYSBmaXhlZCBzaXplZCBjaHVua2luZyBzdHJhdGVneS4gKi9cbiAgcHVibGljIHN0YXRpYyBmaXhlZFNpemUocHJvcHM6IENmbkRhdGFTb3VyY2UuRml4ZWRTaXplQ2h1bmtpbmdDb25maWd1cmF0aW9uUHJvcGVydHkpOiBDaHVua2luZ1N0cmF0ZWd5IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlndXJhdGlvbjoge1xuICAgICAgICBjaHVua2luZ1N0cmF0ZWd5OiBDaHVua2luZ1N0cmF0ZWd5VHlwZS5GSVhFRF9TSVpFLFxuICAgICAgICBmaXhlZFNpemVDaHVua2luZ0NvbmZpZ3VyYXRpb246IHByb3BzLFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgY3VzdG9taXppbmcgYSBoaWVyYXJjaGljYWwgY2h1bmtpbmcgc3RyYXRlZ3kuXG4gICAqIEZvciBjdXN0b20gY2h1bmtpbmcsIHRoZSBtYXhpbXVtIHRva2VuIGNodW5rIHNpemUgZGVwZW5kcyBvbiB0aGUgbW9kZWwuXG4gICAqIC0gQW1hem9uIFRpdGFuIFRleHQgRW1iZWRkaW5nczogODE5MlxuICAgKiAtIENvaGVyZSBFbWJlZCBtb2RlbHM6IDUxMlxuICAqL1xuICBwdWJsaWMgc3RhdGljIGhpZXJhcmNoaWNhbChwcm9wczogSGllcmFyY2hpY2FsQ2h1bmtpbmdQcm9wcyk6IENodW5raW5nU3RyYXRlZ3kge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgIGNodW5raW5nU3RyYXRlZ3k6IENodW5raW5nU3RyYXRlZ3lUeXBlLkhJRVJBUkNISUNBTCxcbiAgICAgICAgaGllcmFyY2hpY2FsQ2h1bmtpbmdDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgb3ZlcmxhcFRva2VuczogcHJvcHMub3ZlcmxhcFRva2VucyxcbiAgICAgICAgICBsZXZlbENvbmZpZ3VyYXRpb25zOiBbXG4gICAgICAgICAgICB7IG1heFRva2VuczogcHJvcHMubWF4UGFyZW50VG9rZW5TaXplIH0sXG4gICAgICAgICAgICB7IG1heFRva2VuczogcHJvcHMubWF4Q2hpbGRUb2tlblNpemUgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmb3IgY3VzdG9taXppbmcgYSBzZW1hbnRpYyBjaHVua2luZyBzdHJhdGVneS5cbiAgICogRm9yIGN1c3RvbSBjaHVua2luZywgdGhlIG1heGltdW0gdG9rZW4gY2h1bmsgc2l6ZSBkZXBlbmRzIG9uIHRoZSBtb2RlbC5cbiAgICogLSBBbWF6b24gVGl0YW4gVGV4dCBFbWJlZGRpbmdzOiA4MTkyXG4gICAqIC0gQ29oZXJlIEVtYmVkIG1vZGVsczogNTEyXG4gICovXG4gIHB1YmxpYyBzdGF0aWMgc2VtYW50aWMocHJvcHM6IENmbkRhdGFTb3VyY2UuU2VtYW50aWNDaHVua2luZ0NvbmZpZ3VyYXRpb25Qcm9wZXJ0eSk6IENodW5raW5nU3RyYXRlZ3kge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgIGNodW5raW5nU3RyYXRlZ3k6IENodW5raW5nU3RyYXRlZ3lUeXBlLlNFTUFOVElDLFxuICAgICAgICBzZW1hbnRpY0NodW5raW5nQ29uZmlndXJhdGlvbjogcHJvcHMsXG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICAvKiogTWV0aG9kIGZvciBkZWZpbmluZyBhIG5vIGNodW5raW5nIHN0cmF0ZWd5LiAqL1xuICBwcml2YXRlIHN0YXRpYyBub0NodW5raW5nKCk6IENodW5raW5nU3RyYXRlZ3kge1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWd1cmF0aW9uOiB7XG4gICAgICAgIGNodW5raW5nU3RyYXRlZ3k6IENodW5raW5nU3RyYXRlZ3lUeXBlLk5PTkUsXG4gICAgICB9LFxuICAgIH07XG4gIH1cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFByb3BlcnRpZXNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKiBUaGUgQ2xvdWRGb3JtYXRpb24gcHJvcGVydHkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb25maWd1cmF0aW9uICovXG4gIHB1YmxpYyBhYnN0cmFjdCBjb25maWd1cmF0aW9uOiBDZm5EYXRhU291cmNlLkNodW5raW5nQ29uZmlndXJhdGlvblByb3BlcnR5O1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7IH1cbn0iXX0=